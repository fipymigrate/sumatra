"""
Commands provided by the smt tool.

Each command corresponds to a function in this module.


:copyright: Copyright 2006-2014 by the Sumatra team, see doc/authors.txt
:license: CeCILL, see LICENSE for details.
"""

import os.path
import sys
import click
from functools import update_wrapper
import warnings
import logging
import sumatra

from sumatra.programs import get_executable
from sumatra.datastore import get_data_store
from sumatra.projects import Project, load_project
from sumatra.launch import get_launch_mode
from sumatra.parameters import build_parameters
from sumatra.recordstore import get_record_store
from sumatra.versioncontrol import (
    get_working_copy, get_repository,
    UncommittedModificationsError
)
from sumatra.formatting import get_diff_formatter
from sumatra.records import MissingInformationError
from sumatra.core import TIMESTAMP_FORMAT

logger = logging.getLogger("Sumatra")
logger.setLevel(logging.CRITICAL)
h = logging.StreamHandler()
h.setFormatter(logging.Formatter('%(asctime)s - %(levelname)s - %(message)s'))
logger.addHandler(h)

logger.debug("STARTING")

store_arg_help = """The argument can take the following forms:
    (1) `/path/to/sqlitedb` - DjangoRecordStore is used with the specified Sqlite database,
    (2) `http[s]://location` - remote HTTPRecordStore is used with a remote Sumatra server,
    (3) `postgres://username:password@hostname/databasename` - DjangoRecordStore is used with specified Postgres database.
    """


# recommended method for modifying warning formatting
# see https://docs.python.org/2/library/warnings.html#warnings.showwarning
def _warning(message, category=UserWarning, filename='', lineno=-1):
    click.echo("Warning: ")
    click.echo(message)
warnings.showwarning = _warning


def parse_executable_str(exec_str):
    """
    Split the string describing the executable into a path part and an
    options part.
    """
    first_space = exec_str.find(" ")
    if first_space == -1:
        first_space = len(exec_str)
    return exec_str[:first_space], exec_str[first_space:]


def parse_arguments(args, input_datastore, stdin=None, stdout=None,
                    allow_command_line_parameters=True):
    cmdline_parameters = []
    script_args = []
    parameter_sets = []
    input_data = []
    for arg in args:
        have_parameters = False
        if os.path.isfile(arg):  # could be a parameter file or a data file
            parameters = build_parameters(arg)
            if parameters is not None:
                parameter_sets.append(parameters)
                script_args.append("<parameters>")
                have_parameters = True
        if not have_parameters:
            if input_datastore.contains_path(arg):
                data_key = input_datastore.generate_keys(arg)
                input_data.extend(data_key)
                script_args.append(arg)
            elif allow_command_line_parameters and "=" in arg:  # cmdline parameter
                cmdline_parameters.append(arg)
            else:  # a flag or something, passed on unchanged
                script_args.append(arg)
    if stdin:
        script_args.append("< %s" % stdin)
        if input_datastore.contains_path(stdin):
            data_key = input_datastore.generate_keys(stdin)
            input_data.extend(data_key)
        else:
            raise IOError("File does not exist: %s" % stdin)
    if stdout:
        script_args.append("> %s" % stdout)
    assert len(parameter_sets) < 2, "No more than one parameter file may be supplied."  # temporary restriction
    if cmdline_parameters:
        if parameter_sets:
            ps = parameter_sets[0]
            for cl in cmdline_parameters:
                try:
                    ps.update(ps.parse_command_line_parameter(cl))
                except ValueError as v:
                    message, name, value = v.args
                    warnings.warn(message)
                    warnings.warn("'{0}={1}' not defined in the parameter file".format(name, value))
                    ps.update({name: value})  # for now, add the command line param anyway
        else:
            raise Exception("Command-line parameters supplied but without a parameter file to put them into.")
            # ought really to have a more specific Exception and to catch it so as to give a helpful error message to user
    return parameter_sets, input_data, " ".join(script_args)


@click.group()
@click.version_option(version=sumatra.__version__, message='%(version)s')
def cli():
    """Simulation/analysis management tool."""


def config_group(fn):
    """Decorator for shared arguments between init and config (the "config group" of commands)"""
    # see http://click.pocoo.org/4/commands/#decorating-commands
    @click.option('-d', '--datapath', metavar='PATH', default='./Data',
                  show_default=True,
                  help="set the path to the directory in which smt will search "
                  "for output datafiles generated by the simulation/analysis.")
    @click.option('-i', '--input', metavar='PATH', default='/', show_default=True,
                  help="set the path to the directory relative to which input "
                  "datafile paths will be given.")
    @click.option('-l', '--addlabel', type=click.Choice(['cmdline', 'parameters']),
                  help="If this option is set, smt will append the record label "
                  "either to the command line (option 'cmdline') or to the "
                  "parameter file (option 'parameters'), and will add the label "
                  "to the datapath when searching for datafiles. It is up to the "
                  "user to make use of this label inside their program to ensure "
                  "files are created in the appropriate location.")
    @click.option('-e', '--executable', metavar='PATH',
                  help="set the path to the executable. If this is not set, smt "
                  "will try to infer the executable from the value of the --main "
                  "option, if supplied, and will try to find the executable from "
                  "the PATH environment variable, then by searching various "
                  "likely locations on the filesystem.")
    @click.option('-r', '--repository', metavar='URL',
                  help="the URL of a Subversion or Mercurial repository "
                  "containing the code. This will be checked out/cloned into "
                  "the current directory.")
    @click.option('-m', '--main', metavar='SCRIPTNAME',
                  help="the name of the script that would be supplied on the "
                  "command line if running the simulation or analysis "
                  "normally, e.g. init.hoc.")
    @click.option('-c', '--on-changed', default='error', show_default=True,
                  help="the action to take if the code in the repository or "
                  "any of the depdendencies has changed.")  # need to add list of allowed values
    @click.option('-g', '--labelgenerator',
                  type=click.Choice(['timestamp', 'uuid']), default='timestamp',
                  help="specify which method Sumatra should use to generate "
                  "labels (options: timestamp, uuid)")
    @click.option('-t', '--timestamp_format',
                  help="the timestamp format given to strftime",
                  default=TIMESTAMP_FORMAT)
    @click.option('-L', '--launch_mode',
                  type=click.Choice(['serial', 'distributed', 'slurm-mpi']),
                  default='serial', show_default=True,
                  help="how computations should be launched.")
    @click.option('-o', '--launch_mode_options',
                  help="extra options for the given launch mode")
    # TODO -- no facility for mutually exclusive group in click
    @click.option('-W', '--webdav', metavar='URL',
                  help="specify a webdav URL (with username@password: if "
                  "needed) as the archiving location for data")
    @click.option('-A', '--archive', metavar='PATH',
                  help="specify a directory in which to archive output datafiles. "
                  "If not specified, or if 'false', datafiles are not archived.")
    @click.option('-M', '--mirror', metavar='URL',
                  help="specify a URL at which your datafiles will be mirrored.")
    @click.pass_context
    def new_func(ctx, *args, **kwargs):
        return ctx.invoke(fn, *args, **kwargs)  # pass with ctx if extend functionality
    return update_wrapper(new_func, fn)


@cli.command()
@click.argument('project_name', metavar='NAME')
@click.option('-s', '--store',
              help="Specify the path, URL or URI to the record store (must be "
              "specified). This can either be an existing record store or one "
              "to be created. {0} Not using the `--store` argument defaults to "
              "a DjangoRecordStore with Sqlite in `.smt/records`".format(store_arg_help))
@config_group
def init(project_name, store, datapath, input, addlabel, executable, repository,
         main, on_changed, labelgenerator, timestamp_format, launch_mode,
         launch_mode_options, webdav, archive, mirror):
    """Create a new project current directory.

    Create a new project called NAME in current directory.
    """
    try:
        project = load_project()
        click.echo("A project already exists in directory '{0}'.".format(project.path), err=True)
    except Exception:
        pass

    if not os.path.exists(".smt"):
        os.mkdir(".smt")

    if repository:
        repository = get_repository(repository)
        repository.checkout()
    else:
        repository = get_working_copy().repository  # if no repository is specified, we assume there is a working copy in the current directory.

    if executable:
        executable_path, executable_options = parse_executable_str(executable)
        executable = get_executable(path=executable_path)
        executable.args = executable_options
    elif main:
        try:
            executable = get_executable(script_file=main)
        except Exception:  # assume unrecognized extension - really need more specific exception type
            # should warn that extension unrecognized
            executable = None
    else:
        executable = None
    if store:
        record_store = get_record_store(store)
    else:
        record_store = 'default'
    if (webdav and archive):
        click.echo("Warn: using webdav though archive is specified")
    if (webdav and mirror):
        click.echo("Warn: using webdav though mirror is specified")
    if (archive and mirror):
        click.echo("Warn: using archive though mirror is specified")
    if webdav:
        output_datastore = get_data_store("DavFsDataStore", {"root": datapath, "dav_url": webdav})
        archive = '.smt/archive'
    elif archive and archive.lower() != 'false':
        if archive.lower() == "true":
            archive = ".smt/archive"
        archive = os.path.abspath(archive)
        output_datastore = get_data_store("ArchivingFileSystemDataStore",
                                          {"root": datapath, "archive": archive})
    elif mirror:
        output_datastore = get_data_store("MirroredFileSystemDataStore",
                                          {"root": datapath, "mirror_base_url": mirror})
    else:
        output_datastore = get_data_store("FileSystemDataStore",
                                          {"root": datapath})
    input_datastore = get_data_store("FileSystemDataStore", {"root": input})

    if launch_mode_options:
        launch_mode_options = launch_mode_options.strip()
    launch_mode = get_launch_mode(launch_mode)(options=launch_mode_options)

    project = Project(name=project_name,
                      default_executable=executable,
                      default_repository=repository,
                      default_main_file=main,  # what if incompatible with executable?
                      default_launch_mode=launch_mode,
                      data_store=output_datastore,
                      record_store=record_store,
                      on_changed=on_changed,
                      data_label=addlabel,
                      input_datastore=input_datastore,
                      label_generator=labelgenerator,
                      timestamp_format=timestamp_format)
    if os.path.exists('.smt'):
        f = open('.smt/labels', 'w')
        f.writelines(project.format_records(tags=None, mode='short', format='text', reverse=False))
        f.close()
    project.save()


@cli.command()
@click.option('--plain/--no-plain', default=False,
              help="pass arguments to the 'run' command straight through to "
              "the program. Otherwise arguments of the form name=value can be "
              "used to overwrite default parameter values. If no-plain, "
              "arguments to the 'run' command of the form name=value will "
              "overwrite default parameter values. This is the opposite of "
              "the --plain option.")
@click.option('-s', '--store',
              help="Change the record store to the specified path, URL or URI "
              "(must be specified). {0}".format(store_arg_help))
@config_group  # decorator only works if up here, changing desired argument ordering
def configure(plain, store, datapath, input, addlabel, executable, repository,
              main, on_changed, labelgenerator, timestamp_format, launch_mode,
              launch_mode_options, webdav, archive, mirror):
    """Modify the settings for the current project."""
    project = load_project()
    if store:
        new_store = get_record_store(store)
        project.change_record_store(new_store)

    if archive:
        if archive.lower() == "true":
            archive = ".smt/archive"
        if hasattr(project.data_store, 'archive_store'):  # current data store is archiving
            if archive.lower() == 'false':
                project.data_store = get_data_store("FileSystemDataStore", {"root": project.data_store.root})
            else:
                project.data_store.archive_store = archive
        else:  # current data store is not archiving
            if archive.lower() != 'false':
                project.data_store = get_data_store("ArchivingFileSystemDataStore", {"root": datapath, "archive": archive})
    if webdav:
        # should we care about archive migration??
        project.data_store = get_data_store("DavFsDataStore", {"root": datapath, "dav_url": webdav})
        project.data_store.archive_store = '.smt/archive'
    if datapath:
        project.data_store.root = datapath
    if input:
        project.input_datastore.root = input
    if repository:
        repository = get_repository(repository)
        repository.checkout()
        project.default_repository = repository
    if main:
        try:
            executable = get_executable(script_file=main)
        except Exception:  # assume unrecognized extension - really need more specific exception type
            # should warn that extension unrecognized
            executable = None
    elif executable:
        executable_path, executable_options = parse_executable_str(executable)
        project.default_executable = get_executable(executable_path,
                                                    script_file=main or project.default_main_file)
        project.default_executable.options = executable_options

    if on_changed:
        project.on_changed = on_changed
    if addlabel:
        project.data_label = addlabel
    if labelgenerator:
        project.label_generator = labelgenerator
    if timestamp_format:
        project.timestamp_format = timestamp_format
    if launch_mode:
        project.default_launch_mode = get_launch_mode(launch_mode)()
    if launch_mode_options:
        project.default_launch_mode.options = launch_mode_options.strip()
    if plain is not None:
        project.allow_command_line_parameters = not plain
    project.save()


@cli.command()
def info():
    """Print information about the current project."""
    try:
        project = load_project()  # should config pass cwd?
    except IOError as err:
        click.echo(err, err=True)
        sys.exit(1)
    click.echo(project.info())


@cli.command(context_settings=dict(ignore_unknown_options=True, ))
@click.option('-v', '--version', metavar='REV',
              help="use version REV of the code (if this is not the same as the "
              "working copy, it will be checked out of the repository). If this "
              "option is not specified, the most recent version in the "
              "repository will be used. If there are changes in the working "
              "copy, the user will be prompted to commit them first")
@click.option('-l', '--label', metavar='LABEL',
              help="specify a label for the experiment. If no label is "
              "specified, one will be generated automatically.")
@click.option('-r', '--reason',
              help="explain the reason for running this simulation/analysis.")
@click.option('-e', '--executable', metavar='PATH',
              help="Use this executable for this run. If not specified, the "
              "project's default executable will be used.")
@click.option('-m', '--main', metavar='SCRIPTNAME',
              help="the name of the script that would be supplied on the "
              "command line if running the simulation/analysis normally, e.g. "
              "init.hoc. If not specified, the project's default will be used.")
@click.option('-n', '--num_processes', metavar='N', type=int,
              help="run a distributed computation on N processes using MPI. "
              "If this option is not used, or if N=0, a normal, serial "
              "simulation/analysis is run.")
@click.option('-t', '--tag', help="tag you want to add to the project")
@click.option('-D', '--debug', is_flag=True,
              help="print debugging information.")
@click.option('-i', '--stdin',
              help="specify the name of a file that should be connected to standard input.")
@click.option('-o', '--stdout',
              help="specify the name of a file that should be connected to standard output.")
@click.argument('user_args', metavar='[arg1, ...] [param=value, ...]',
                nargs=-1, type=click.UNPROCESSED)
def run(version, label, reason, executable, main, num_processes, tag, debug, stdin, stdout, user_args):
    """Run a simulation or analysis.

    The list of arguments will be passed on to the simulation/analysis script.
    It should normally contain at least the name of a parameter file, but
    can also contain input files, flags, etc.

    If the parameter file should be in a format that Sumatra understands (see
    documentation), then the parameters will be stored to allow future
    searching, comparison, etc. of records.

    For convenience, it is possible to specify a file with default parameters
    and then specify those parameters that are different from the default values
    on the command line with any number of param=value pairs (note no space
    around the equals sign)."""
    if debug:
        logger.setLevel(logging.DEBUG)

    project = load_project()
    parameters, input_data, script_args = parse_arguments(user_args,
                                                          project.input_datastore,
                                                          stdin,
                                                          stdout,
                                                          project.allow_command_line_parameters)
    if len(parameters) == 0:
        parameters = {}
    elif len(parameters) == 1:
        parameters = parameters[0]
    else:
        click.echo("Only a single parameter file allowed.", err=True)  # for now

    if executable:
        executable_path, executable_options = parse_executable_str(executable)
        executable = get_executable(path=executable_path)
        executable.options = executable_options
    elif main:
        executable = get_executable(script_file=main)  # should we take the options from project.default_executable, if they match?
    else:
        executable = 'default'
    if num_processes:
        if hasattr(project.default_launch_mode, 'n'):
            project.default_launch_mode.n = num_processes
        else:
            click.echo("Your current launch mode does not support using multiple processes.", err=True)
    reason = reason or ''
    if reason:
        reason = reason.strip('\'"')

    label = label
    try:
        run_label = project.launch(parameters, input_data, script_args,
                                   label=label, reason=reason,
                                   executable=executable,
                                   main_file=main or 'default',
                                   version=version or 'current')
    except (UncommittedModificationsError, MissingInformationError) as err:
        click.echo(err, err=True)
        sys.exit(1)
    if tag:
        project.add_tag(run_label, tag)


@cli.command()
@click.argument('tags', nargs=-1, required=False)
@click.option('-l', '--long', 'mode', flag_value='long',
              help="prints full information for each record")
@click.option('-T', '--table', 'mode', flag_value='table',
              help="prints information in tab-separated columns")
@click.option('-f', '--format', metavar='FMT', show_default = True,
              type=click.Choice(['text','html', 'latex', 'shell']),
              default='text')
@click.option('-r', '--reverse', is_flag=True,
              help="list records in reverse order (default: newest first)")
def list(tags, mode, format, reverse):  # add 'report' and 'log' as aliases
    """List records in current project.

    If TAGS (optional) is specified, then only records with a tag in TAGS
    will be listed."""
    if mode is None:
        mode = 'short'

    project = load_project()
    project_list = project.format_records(tags=tags, mode=mode, format=format, reverse=reverse)
    # below for bash completion
    if os.path.exists('.smt'):
        f = open('.smt/labels', 'w')
        f.writelines(project.format_records(tags=None, mode='short', format='text', reverse=False))
        f.close()
    click.echo(project_list)  # TODO -- for table output weird wrapping occurrs


@cli.command()
@click.argument('labels', metavar='LIST', nargs=-1, required=True)
@click.option('-t', '--tag', is_flag=True,
              help="interpret LIST as containing tags. Records with any of "
              "these tags will be deleted.")
@click.option('-d', '--data', is_flag=True,
              help="also delete any data associated with the record(s).")
def delete(labels, tag, data):
    """Delete records from a project.

    LIST should be a space-separated list of labels for individual records or
    of tags. If it contains tags, you must set the --tag/-t option (see below).
    The special value "last" allows you to delete the most recent simulation/analysis.
    If you want to delete all records, just delete the .smt directory and use
    smt init to create a new, empty project.
    """
    project = load_project()

    if tag:
        for tag in labels:
            n = project.delete_by_tag(tag, delete_data=data)
            click.echo("%s records deleted." % n)
    else:
        for label in labels:
            if label == 'last':
                label = project.most_recent().label
            try:
                project.delete_record(label, delete_data=data)
            except Exception:
                # could be KeyError or DoesNotExist
                #: should create standard NoSuchRecord or RecordDoesNotExist exception
                warnings.warn("Could not delete record '%s' because it does not exist" % label)


@cli.command()
@click.argument('comment', required=True)  # TODO -- had to switch order figure out how to swithc back
@click.argument('label', required=False)
@click.option('-r', '--replace', is_flag=True,
              help="""if this flag is set, any existing comment will be "
              "overwritten, otherwise, the new comment will be appended to the "
              "end, starting on a new line""")
@click.option('-f', '--file', is_flag=True,
              help="interpret COMMENT as the path to a file containing the comment")
def comment(label, comment, replace, file):
    """Add a comment to an existing record.

    Add COMMENT, a description of the outcome of the simulation or
    analysis, to record LABEL. If LABEL is omitted, the comment will
    be added to the most recent experiment. If the '-f/--file' option
    is set, COMMENT should be the name of a file containing the
    comment, otherwise it should be a string of text. By default,
    comments will be appended to any existing comments. To overwrite
    existing comments, use the '-r/--replace flag.
    """

    if file:
        f = open(comment, 'r')
        comment = f.read()
        f.close()
    else:
        comment = comment
    project = load_project()
    label = label or project.most_recent().label
    project.add_comment(label, comment, replace=replace)


@cli.command()
@click.argument('tag', metavar='TAG', nargs=1, required=True)
@click.argument('labels', nargs=-1, metavar="[LIST]", required=False)
@click.option('-r', '--remove', is_flag=True,
              help="remove the tag from the record(s), rather than adding it.")
def tag(tag, labels, remove):
    """Tag or un-tag records.

    TAG the space-separate LIST of labels for individual records. If
    TAG contains spaces, it must be enclosed in quotes. If LIST is
    omitted, only the most recent record will be tagged. If the
    '-d/--delete' option is set, the tag will be removed from the
    records.
    """
    project = load_project()
    if remove:
        op = project.remove_tag
    else:
        op = project.add_tag
    labels = labels or [project.most_recent().label]
    for label in labels:
        op(label, tag)


@cli.command()
@click.argument('original_label', metavar='LABEL')
@click.option('-l', '--label', metavar='NEW_LABEL',
              help="specify a label for the new experiment. If no label is "
              "specified, one will be generated automatically.")
def repeat(original_label, label):
    """Re-run a previous simulation or analysis.

    Re-run the simulation LABEL under (in theory) identical
    conditions, and check that the results are unchanged."""
    project = load_project()
    new_label, original_label = project.repeat(original_label, label)
    diff = project.compare(original_label, new_label)
    if diff:
        formatter = get_diff_formatter()(diff)
        msg = ["The new record does not match the original. It differs as follows.",
               formatter.format('short'),
               "run smt diff --long %s %s to see the differences in detail." % (original_label, new_label)]
        msg = "\n".join(msg)
    else:
        msg = "The new record exactly matches the original."
    click.echo(msg)
    project.add_comment(new_label, msg)


@cli.command()
@click.argument('label1', required=True)
@click.argument('label2', required=True)
@click.option('-i', '--ignore', multiple=True,
              help="a regular expression pattern for filenames to ignore when "
                    "evaluating differences in output data. To supply multiple "
                    "patterns, use the -i option multiple times.")
@click.option('-l', '--long', 'mode', flag_value='long',
              help="prints full information for each record")
def diff(label1, label2, ignore, mode):
    """Show the differences between two records.

    Records identified by LABEL1 and LABEL2 are differenced and the
    output printed.
    """
    if mode is None:
        mode = 'short'

    project = load_project()
    click.echo(project.show_diff(label1, label2, mode=mode,
                                 ignore_filenames=ignore))


@cli.command()
@click.argument('cmd', nargs=1, required=False)
def help(cmd):
    """Get help on an smt command."""

    if cmd is None:
        cli(['--help'])
    else:
        try:
            cli([cmd, '--help'])
        except KeyError:
            click.echo('"%s" is not an smt command.' % cmd, err=True)


@cli.command()
def upgrade():
    """Upgrade an existing Sumatra project.

    You must have previously run "smt export" or the standalone 'export.py' script.
    """
    project = load_project()
    if hasattr(project, 'sumatra_version') and project.sumatra_version == sumatra.__version__:
        click.echo("No upgrade needed (project was created with an up-to-date version of Sumatra).")
        sys.exit(1)

    if not os.path.exists(".smt/project_export.json"):
        click.echo("Error: project must have been exported (with the original "
                   "version of Sumatra) before upgrading.", err=True)
        sys.exit(1)

    # backup and remove .smt
    import shutil
    backup_dir = project.backup()
    shutil.rmtree(".smt")
    # upgrade the project data
    os.mkdir(".smt")
    shutil.copy("%s/project_export.json" % backup_dir, ".smt/project")
    project.sumatra_version = sumatra.__version__
    project.save()
    # upgrade the record store
    project.record_store.clear()
    filename = "%s/records_export.json" % backup_dir
    if os.path.exists(filename):
        f = open(filename)
        project.record_store.import_(project.name, f.read())
        f.close()
    else:
        click.echo("Record file not found")
        sys.exit(1)
    click.echo("Project successfully upgraded to Sumatra "
               "version {}.".format(project.sumatra_version))


@cli.command()
def export():
    """Export Sumatra project records to JSON.

    This is needed before running upgrade."""
    project = load_project()
    project.export()


@cli.command()
@click.argument('path1', required=True)
@click.argument('path2', required=False)
def sync(path1, path2):
    """Synchronize two record stores.

    If both PATH1 and PATH2 are given, the
    record stores at those locations will be synchronized. If only PATH1 is
    given, and the command is run in a directory containing a Sumatra
    project, only that project's records be synchronized with the store at
    PATH1. Note that PATH1 and PATH2 may be either filesystem paths or URLs.
    """
    # need to say what happens if the sync is incomplete due to label collisions
    store1 = get_record_store(path1)
    if path2:
        store2 = get_record_store(path2)
        collisions = store1.sync_all(store2)
    else:
        project = load_project()
        store2 = project.record_store
        collisions = store1.sync(store2, project.name)

    if collisions:
        click.echo("Synchronization incomplete: there are two records with the "
                   "same name for the following: %s" % ", ".join(collisions))
        sys.exit(1)


@cli.command()
@click.option('-d', '--datapath', metavar='PATH',
              help="modify the path to the directory in which your results "
              "are stored.")
@click.option('-i', '--input', metavar='PATH',
              help="modify the path to the directory in which your input "
              "data files are stored.")
@click.option('-A', '--archive', metavar='PATH',
              help="modify the directory in which your results are archived.")
@click.option('-M', '--mirror', metavar='URL',
              help="modify the URL at which your data files are mirrored.")
def migrate(**kwargs):
    """Update location of data files.

    If you have moved your data files to a new location, update the record
    store to reflect the new paths.
    """
    # might also want to update the repository upstream
    # should we keep a history of such changes?
    project = load_project()
    field_map = {
        "datapath": "datastore.root",
        "input": "input_datastore.root",
        "archive": "datastore.archive",
        "mirror": "datastore.mirror_base_url"
    }
    if not any(kwargs.values()):
        warnings.warn(
            "Command 'smt migrate' had no effect. Please provide at least one "
            "argument. (Run 'smt help migrate' for help.)")
    else:
        for option_name, field in field_map.items():
            value = kwargs.pop(option_name)
            if value is not None:
                project.record_store.update(project.name, field, value)


@cli.command()
def version():
    """Print the Sumatra version."""
    cli(['--version'])
